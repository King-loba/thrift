/**
 * Autogenerated by Thrift Compiler (PATCHED VERSION with TASK_6088 security fix)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "test_task_6088_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace test { namespace task6088 {

// ========== MiddleContainer Implementation (PATCHED) ==========

uint32_t MiddleContainer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_containerId = false;
  bool isset_dataItems = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->containerId);
          isset_containerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            // ========== PATCHED: Added security validation ==========
            this->dataItems.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);

            // ✅ SECURITY FIX: Validate size before allocation
            if (_size0 > 16777216) {
              throw ::apache::thrift::protocol::TProtocolException(
                ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT,
                "List size exceeds maximum: " + std::to_string(_size0) +
                " > " + std::to_string(16777216));
            }

            // Now safe to allocate
            this->dataItems.resize(_size0);

            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              // ✅ DEFENSE-IN-DEPTH: Runtime bounds check
              if (_i4 >= 16777216) {
                throw ::apache::thrift::protocol::TProtocolException(
                  ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT);
              }

              xfer += this->dataItems[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_dataItems = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_containerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataItems)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

// ========== OuterStructure Implementation (PATCHED) ==========

uint32_t OuterStructure::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_timestamp = false;
  bool isset_containers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          isset_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            // ========== PATCHED: List with validation ==========
            this->containers.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);

            // ✅ SECURITY FIX: Check size before resize
            if (_size6 > 16777216) {
              throw ::apache::thrift::protocol::TProtocolException(
                ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT,
                "List size exceeds maximum: " + std::to_string(_size6) +
                " > " + std::to_string(16777216));
            }

            this->containers.resize(_size6);

            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              // ✅ DEFENSE-IN-DEPTH: Loop bounds check
              if (_i10 >= 16777216) {
                throw ::apache::thrift::protocol::TProtocolException(
                  ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT);
              }

              // Recursive call - MiddleContainer also has protections
              xfer += this->containers[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_containers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            // ========== PATCHED: Map with validation ==========
            this->namedGroups.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _ktype12;
            ::apache::thrift::protocol::TType _vtype13;
            xfer += iprot->readMapBegin(_ktype12, _vtype13, _size11);

            // ✅ SECURITY FIX: Validate map size
            if (_size11 > 16777216) {
              throw ::apache::thrift::protocol::TProtocolException(
                ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT,
                "Map size exceeds maximum: " + std::to_string(_size11) +
                " > " + std::to_string(16777216));
            }

            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              // ✅ DEFENSE-IN-DEPTH: Loop bounds check
              if (_i15 >= 16777216) {
                throw ::apache::thrift::protocol::TProtocolException(
                  ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT);
              }

              std::string _key16;
              xfer += iprot->readString(_key16);
              std::vector<InnerData> & _val17 = this->namedGroups[_key16];
              {
                // ========== PATCHED: Nested list in map also validated ==========
                _val17.clear();
                uint32_t _size18;
                ::apache::thrift::protocol::TType _etype21;
                xfer += iprot->readListBegin(_etype21, _size18);

                // ✅ SECURITY FIX: Validate nested list size too!
                if (_size18 > 16777216) {
                  throw ::apache::thrift::protocol::TProtocolException(
                    ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT,
                    "List size exceeds maximum: " + std::to_string(_size18) +
                    " > " + std::to_string(16777216));
                }

                _val17.resize(_size18);

                uint32_t _i22;
                for (_i22 = 0; _i22 < _size18; ++_i22)
                {
                  // ✅ DEFENSE-IN-DEPTH: Even nested loops are protected
                  if (_i22 >= 16777216) {
                    throw ::apache::thrift::protocol::TProtocolException(
                      ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT);
                  }

                  xfer += _val17[_i22].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.namedGroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_timestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_containers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

// ========== DeepNesting Implementation (PATCHED) ==========

uint32_t DeepNesting::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_depth = false;
  bool isset_nestedLists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->depth);
          isset_depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            // ========== PATCHED: Outer list of list<list<InnerData>> ==========
            this->nestedLists.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);

            // ✅ CRITICAL: Validate outer list size
            // Without this, attacker could claim 10,000 outer elements
            if (_size26 > 16777216) {
              throw ::apache::thrift::protocol::TProtocolException(
                ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT,
                "List size exceeds maximum: " + std::to_string(_size26) +
                " > " + std::to_string(16777216));
            }

            this->nestedLists.resize(_size26);

            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              // ✅ Loop check
              if (_i30 >= 16777216) {
                throw ::apache::thrift::protocol::TProtocolException(
                  ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT);
              }

              {
                // ========== PATCHED: Inner list ==========
                this->nestedLists[_i30].clear();
                uint32_t _size31;
                ::apache::thrift::protocol::TType _etype34;
                xfer += iprot->readListBegin(_etype34, _size31);

                // ✅ CRITICAL: Validate inner list size too!
                // Without this: 10,000 outer × 100,000 inner = 1 BILLION allocations!
                if (_size31 > 16777216) {
                  throw ::apache::thrift::protocol::TProtocolException(
                    ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT,
                    "List size exceeds maximum: " + std::to_string(_size31) +
                    " > " + std::to_string(16777216));
                }

                this->nestedLists[_i30].resize(_size31);

                uint32_t _i35;
                for (_i35 = 0; _i35 < _size31; ++_i35)
                {
                  // ✅ Inner loop check
                  if (_i35 >= 16777216) {
                    throw ::apache::thrift::protocol::TProtocolException(
                      ::apache::thrift::protocol::TProtocolException::SIZE_LIMIT);
                  }

                  xfer += this->nestedLists[_i30][_i35].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_nestedLists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_depth)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nestedLists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

// ========== SECURITY ANALYSIS ==========

/*
BEFORE PATCH - Attack Success Scenario:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Attacker sends:
  nestedLists: outer_size=10000, inner_size=100000

Memory allocation:
  Line resize(_size26): 10,000 vectors allocated (~80 KB)
  Line resize(_size31): 10,000 × 100,000 = 1,000,000,000 InnerData
  Total memory: 1B × 32 bytes = 32 GB

Result: Process crashes with std::bad_alloc
Cost to attacker: ~100 bytes of payload
Cost to victim: 32 GB allocation attempt + crash

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

AFTER PATCH - Attack Failure Scenario:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Attacker sends same payload.

Execution flow:
  1. Read outer size: _size26 = 10,000
  2. Check: 10,000 > 16,777,216? NO → Continue
  3. Allocate outer vector: OK (small)
  4. Enter outer loop: _i30 = 0
  5. Read inner size: _size31 = 100,000
  6. Check: 100,000 > 16,777,216? NO → Continue
  7. Allocate inner vector: OK (manageable)
  8. Process continues safely...

If attacker tries larger size:
  1. Read outer size: _size26 = 100,000,000
  2. Check: 100,000,000 > 16,777,216? YES!
  3. ✅ Throw SIZE_LIMIT exception
  4. No allocation performed
  5. Exception caught and logged
  6. Process remains stable

Result: Attack prevented, service continues
Cost to victim: ~100 CPU cycles + exception handling
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

PROTECTION LAYERS:

Layer 1: Pre-resize validation
  - Catches oversized claims before any allocation
  - Prevents std::bad_alloc crashes
  - 0% memory waste

Layer 2: Loop iteration checks
  - Defense-in-depth if size changes during execution
  - Catches protocol bugs or memory corruption
  - Minimal CPU overhead

Layer 3: Nested validation
  - Each nesting level independently validated
  - Prevents amplification attacks (many small containers)
  - Total memory still bounded

Maximum possible allocation:
  - Single container: 16M × element_size
  - For 32-byte InnerData: 512 MB (manageable)
  - For nested lists: Still bounded per level
  - Total worst case: Bounded and predictable
*/

}} // namespace
